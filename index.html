<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Carte Chemins et Loamness</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
      /* Style minimal pour la carte */
      body, html { margin:0; padding:0; }
      #map { width:100%; height:100vh; }
      .info {
          padding: 6px 8px;
          font: 14px/16px Arial, Helvetica, sans-serif;
          background: white;
          background: rgba(255,255,255,0.8);
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
          border-radius: 5px;
      }
      .legend {
          line-height: 18px;
          color: #555;
      }
      .legend i {
          width: 18px;
          height: 18px;
          float: left;
          margin-right: 8px;
          opacity: 0.7;
      }
      .filter-control {
          background: white;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
      }
      .filter-control h4 {
          margin: 0 0 5px 0;
          font-size: 16px;
      }
      .filter-control label {
          font-size: 14px;
      }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Georaster JS (version 1.6.0) -->
<script src="https://cdn.jsdelivr.net/npm/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
<!-- GeoRasterLayer for Leaflet JS (version 2.3.1) -->
<script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
<!-- TopoJSON JS -->
<script src="https://unpkg.com/topojson@3/dist/topojson.min.js"></script>

<script>
    // Vérification du chargement des bibliothèques
    console.log("Georaster loaded:", typeof parseGeoraster); // Doit afficher 'function'
    console.log("GeoRasterLayer loaded:", typeof GeoRasterLayer); // Doit afficher 'function'
    console.log("TopoJSON loaded:", typeof topojson); // Doit afficher 'object'

    (async function(){
      try {
        // Vérifiez que les bibliothèques sont chargées
        if (typeof parseGeoraster !== 'function') {
          throw new Error("parseGeoraster n'est pas défini. Vérifiez le chargement de la bibliothèque Georaster.");
        }
        if (typeof GeoRasterLayer !== 'function') {
          throw new Error("GeoRasterLayer n'est pas défini. Vérifiez le chargement de la bibliothèque GeoRasterLayer.");
        }
        if (typeof topojson !== 'object') {
          throw new Error("topojson n'est pas défini. Vérifiez le chargement de la bibliothèque TopoJSON.");
        }

        // 1) Charger la config locale
        // Ici, on charge config/Hérault_config.json
        // Dedans, on a "topojson_url": "https://drive.google.com/uc?export=download&id=1hBlnAL6Mm-ChjTWL_pRg5gyD5VuDexf1"
        const responseConfig = await fetch('config/Hérault_config.json');  // Remplacez 'Hérault' par votre département
        if(!responseConfig.ok){
          throw new Error("Erreur lors du chargement du fichier de configuration.");
        }
        const config = await responseConfig.json();
      
        const topojsonUrl = config.topojson_url; // => lien Google Drive direct
        const rasterUrl   = config.raster_url;   // => par ex. GitHub Pages

        // 2) Initialiser la carte
        const map = L.map('map').setView([43.6, 3.87], 8); // Centrez selon votre département
      
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom:19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
      
        // 3) Ajouter une couche d'informations
        const info = L.control();
      
        info.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'info');
            this.update();
            return this._div;
        };
      
        info.update = function (props) {
            this._div.innerHTML = '<h4>Difficulté des Chemins</h4>' +  (props
                ? '<b>' + (props.nom || props.difficulty_clean || 'N/A') + '</b><br />' + props.difficulty
                : 'Sélectionnez un chemin');
        };
      
        info.addTo(map);
      
        // 4) Créer une légende pour les chemins
        const legend = L.control({position: 'bottomright'});
      
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend'),
                grades = ["inconnu", "très facile", "facile", "modéré", "difficile", "très difficile"],
                colors = ["gray", "#00FF00", "#FFFF00", "#FFA500", "#FF0000", "#8B0000"];
    
            for (let i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<i style="background:' + colors[i] + '"></i> ' +
                    grades[i] + '<br>';
            }
            return div;
        };
      
        legend.addTo(map);
      
        // 5) Charger le TopoJSON et préparer la couche GeoJSON
        const respTopo = await fetch(topojsonUrl);
        if(!respTopo.ok){
          throw new Error("Fichier TopoJSON introuvable (ou lien Google Drive invalide).");
        }
        const topoData = await respTopo.json();
      
        if(!topoData.objects){
          throw new Error("Pas d'objet 'objects' dans le TopoJSON. Vérifiez votre fichier.");
        }
        // On prend le nom du premier objet si on ne le connaît pas
        const topoObjectName = Object.keys(topoData.objects)[0];
        const geoData = topojson.feature(topoData, topoData.objects[topoObjectName]);
      
        console.log("GeoJSON Data:", geoData);
        if (geoData.features.length === 0) {
            throw new Error("Aucun feature trouvé dans le GeoJSON.");
        }
      
        // Vérifier les propriétés
        console.log("Propriétés du premier feature:", geoData.features[0].properties);
      
        // Palette de couleurs en fonction de 'difficulty'
        const difficultyColors = {
          "inconnu": "gray",
          "très facile": "#00FF00",
          "facile": "#FFFF00",
          "modéré": "#FFA500",
          "difficile": "#FF0000",
          "très difficile": "#8B0000"
        };
      
        // Indexer par difficulté
        const featuresByDifficulty = {};
        geoData.features.forEach(feature => {
            const difficulty = feature.properties.difficulty;
            if (!featuresByDifficulty[difficulty]) {
                featuresByDifficulty[difficulty] = [];
            }
            featuresByDifficulty[difficulty].push(feature);
        });
  
        // Couche GeoJSON vide initialement
        const geojsonLayer = L.geoJSON(null, {
            style: function(feature){
                const diff = feature.properties.difficulty;
                return { 
                    color: difficultyColors[diff] || "black",
                    weight: 3,
                    opacity: 1 
                };
            },
            onEachFeature: function(feature, layer){
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: zoomToFeature
                });
                layer.bindPopup(
                  `<b>${feature.properties.nom || feature.properties.difficulty_clean || 'N/A'}</b><br>Difficulté: ${feature.properties.difficulty}`
                );
            }
        }).addTo(map);
      
        // Définir la fonction debounce
        function debounce(func, delay) {
            let inDebounce;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(inDebounce);
                inDebounce = setTimeout(() => func.apply(context, args), delay);
            }
        }
        const debouncedUpdate = debounce(updateGeoJSONLayer, 300);
      
        // Fonctions d'interactivité
        function highlightFeature(e) {
            const layer = e.target;
            layer.setStyle({
                weight: 5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.7
            });
            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                layer.bringToFront();
            }
            info.update(layer.feature.properties);
        }
    
        function resetHighlight(e) {
            geojsonLayer.resetStyle(e.target);
            info.update();
        }
    
        function zoomToFeature(e) {
            map.fitBounds(e.target.getBounds());
        }
      
        // 6) Contrôle de Filtrage
        const filterControl = L.control({position: 'topright'});
  
        filterControl.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info filter-control');
            div.innerHTML = `
                <h4>Filtrer par Difficulté</h4>
                <label><input type="checkbox" value="inconnu" checked> Inconnu</label><br>
                <label><input type="checkbox" value="très facile" checked> Très Facile</label><br>
                <label><input type="checkbox" value="facile" checked> Facile</label><br>
                <label><input type="checkbox" value="modéré" checked> Modéré</label><br>
                <label><input type="checkbox" value="difficile" checked> Difficile</label><br>
                <label><input type="checkbox" value="très difficile" checked> Très Difficile</label><br>
            `;
            L.DomEvent.disableClickPropagation(div);
            const checkboxes = div.querySelectorAll('input[type=checkbox]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', debouncedUpdate);
            });
            return div;
        };
        filterControl.addTo(map);
  
        // 7) Fonction de Mise à Jour de la Couche GeoJSON en Fonction des Filtres
        function updateGeoJSONLayer() {
            const checkedDifficulties = Array.from(
              document.querySelectorAll('.filter-control input[type=checkbox]:checked')
            ).map(cb => cb.value);
            
            geojsonLayer.clearLayers();
            
            let filteredFeatures = [];
            checkedDifficulties.forEach(difficulty => {
                if (featuresByDifficulty[difficulty]) {
                    filteredFeatures = filteredFeatures.concat(featuresByDifficulty[difficulty]);
                }
            });
            
            const filteredData = {
                "type": "FeatureCollection",
                "features": filteredFeatures
            };
            
            geojsonLayer.addData(filteredData);
        }
  
        // 8) Charger le Raster Loamness et l'ajouter
        try {
          const responseRaster = await fetch(rasterUrl);
          if(!responseRaster.ok){
            throw new Error("Fichier Raster Loamness introuvable ou lien invalide.");
          }
          const arrayBuffer = await responseRaster.arrayBuffer();
          
          const georaster = await parseGeoraster(arrayBuffer);
      
          const rasterLayer = new GeoRasterLayer({
            georaster: georaster,
            opacity: 0.6,
            pixelValuesToColorFn: values => {
              if (values[0] === null || isNaN(values[0])) return null;
              const loam = values[0];
              if (loam >= 95) return 'rgba(0, 0, 139, 0.6)';        
              if (loam >= 90) return 'rgba(0, 100, 0, 0.6)';        
              if (loam >= 85) return 'rgba(34, 139, 34, 0.6)';      
              if (loam >= 80) return 'rgba(144, 238, 144, 0.6)';    
              return null; // < 80% => transparent
            },
            resolution: 256
          });
      
          rasterLayer.addTo(map);
      
          // Légende du raster Loamness
          const rasterLegend = L.control({position: 'bottomleft'});
      
          rasterLegend.onAdd = function (map) {
              const div = L.DomUtil.create('div', 'info legend'),
                  grades = [80, 85, 90, 95, 100],
                  labels = ["80% – 85%", "85% – 90%", "90% – 95%", "95% – 100%"],
                  colors = [
                      "rgba(144, 238, 144, 0.6)",
                      "rgba(34, 139, 34, 0.6)",
                      "rgba(0, 100, 0, 0.6)",
                      "rgba(0, 0, 139, 0.6)"
                  ];
      
              for (let i = 0; i < labels.length; i++) {
                  div.innerHTML +=
                      '<i style="background:' + colors[i] + '"></i> ' +
                      labels[i] + '<br>';
              }
              return div;
          };
      
          rasterLegend.addTo(map);
      
          // Initialiser la couche Chemins + Filtres
          updateGeoJSONLayer();
      
        } catch(err){
          console.error("Erreur chargement Raster Loamness:", err);
          alert("Erreur chargement Raster Loamness (voir console).");
        }
      
      } catch(err){
        console.error("Erreur générale:", err);
        alert("Erreur générale lors du chargement de la carte: " + err.message);
      }
    })();
</script>

</body>
</html>
