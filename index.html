<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Carte Chemins et Loamness</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
      /* Style minimal pour la carte */
      body, html { margin:0; padding:0; }
      #map { width:100%; height:100vh; }
      .info {
          padding: 6px 8px;
          font: 14px/16px Arial, Helvetica, sans-serif;
          background: white;
          background: rgba(255,255,255,0.8);
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
          border-radius: 5px;
      }
      .legend {
          line-height: 18px;
          color: #555;
      }
      .legend i {
          width: 18px;
          height: 18px;
          float: left;
          margin-right: 8px;
          opacity: 0.7;
      }
      .filter-control {
          background: white;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
      }
      .filter-control h4 {
          margin: 0 0 5px 0;
          font-size: 16px;
      }
      .filter-control label {
          font-size: 14px;
      }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Georaster JS (version 1.6.0) -->
<script src="https://cdn.jsdelivr.net/npm/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
<!-- GeoRasterLayer for Leaflet JS (version 2.3.1) -->
<script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
<!-- TopoJSON JS -->
<script src="https://unpkg.com/topojson@3/dist/topojson.min.js"></script>

<script>
    // Vérification du chargement des bibliothèques
    console.log("Georaster loaded:", typeof parseGeoraster); // Doit afficher 'function'
    console.log("GeoRasterLayer loaded:", typeof GeoRasterLayer); // Doit afficher 'function'
    console.log("TopoJSON loaded:", typeof topojson); // Doit afficher 'object'

    (async function(){
      try {
        // Vérifiez que les bibliothèques sont chargées
        if (typeof parseGeoraster !== 'function') {
          throw new Error("parseGeoraster n'est pas défini. Vérifiez le chargement de la bibliothèque Georaster.");
        }
        if (typeof GeoRasterLayer !== 'function') {
          throw new Error("GeoRasterLayer n'est pas défini. Vérifiez le chargement de la bibliothèque GeoRasterLayer.");
        }
        if (typeof topojson !== 'object') {
          throw new Error("topojson n'est pas défini. Vérifiez le chargement de la bibliothèque TopoJSON.");
        }

        // 1) Charger la config locale
        const responseConfig = await fetch('config/Hérault_config.json');  // Remplacez 'Hérault' par votre département
        if(!responseConfig.ok){
          throw new Error("Erreur lors du chargement du fichier de configuration.");
        }
        const config = await responseConfig.json();
        console.log("Config loaded:", config); // Ajouté pour le débogage

        const topojsonUrl = config.topojson_url; // => lien GitHub Pages
        const rasterUrl   = config.raster_url;   // => par ex. GitHub Pages

        // 2) Initialiser la carte
        const map = L.map('map').setView([43.6, 3.87], 8); // Centrez selon votre département

        // Définir les couches de base
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom:19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map); // Ajouté par défaut

        // Couches satellite et labels d'Esri
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
        });

        const labels = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
        });

        // Grouper satellite et labels pour une vue hybride
        const satelliteLabels = L.layerGroup([satellite, labels]);

        // Contrôle des couches de base
        const baseLayers = {
          "OSM": osm,
          "Satellite Hybride": satelliteLabels
        };

        L.control.layers(baseLayers).addTo(map);

        // 3) Ajouter une couche d'informations
        const info = L.control();

        info.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'info');
            this.update();
            return this._div;
        };

        info.update = function (props) {
            this._div.innerHTML = '<h4>Difficulté des Chemins</h4>' +  (props
                ? `<b>${props.nom || props.difficulty_clean || 'N/A'}</b><br />
                   Difficulté: ${props.difficulty}<br />
                   Pente Moyenne: ${props.slope_mean !== null ? props.slope_mean.toFixed(2) : 'N/A'}°<br />
                   Pente Maximum: ${props.slope_max !== null ? props.slope_max.toFixed(2) : 'N/A'}°`
                : 'Sélectionnez un chemin');
        };

        info.addTo(map);

        // 4) Créer une légende pour les chemins et le loamness
        const legend = L.control({position: 'bottomright'});

        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend'),
                grades = ["inconnu", "très facile", "facile", "modéré", "difficile", "très difficile"],
                colors = ["gray", "#00FF00", "#FFFF00", "#FFA500", "#FF0000", "#8B0000"];

            for (let i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<i style="background:' + colors[i] + '"></i> ' +
                    grades[i] + '<br>';
            }

            // Ajouter une séparation et une explication pour le Loamness
            div.innerHTML += '<hr><strong>Loamness (%)</strong><br>';
            div.innerHTML += 'Indice de Loamness : Mesure la proportion de sable, limon et argile dans le sol pour déterminer sa compatibilité avec le VTT. Des sols avec des proportions équilibrées favorisent une meilleure adhérence et maniabilité sur les sentiers.<br><br>';

            // Ajouter une séparation et une explication pour la Pente
            div.innerHTML += '<strong>Pente</strong><br>';
            div.innerHTML += 'Pente Moyenne : Inclinaison moyenne du chemin.<br>';
            div.innerHTML += 'Pente Maximum : Inclinaison maximale rencontrée sur le chemin.';
            return div;
        };

        legend.addTo(map);

        // 5) Charger le TopoJSON et préparer la couche GeoJSON
        const respTopo = await fetch(topojsonUrl);
        if(!respTopo.ok){
          throw new Error("Fichier TopoJSON introuvable (ou lien GitHub Pages invalide).");
        }
        const topoData = await respTopo.json();

        if(!topoData.objects){
          throw new Error("Pas d'objet 'objects' dans le TopoJSON. Vérifiez votre fichier.");
        }
        // On prend le nom du premier objet si on ne le connaît pas
        const topoObjectName = Object.keys(topoData.objects)[0];
        const geoData = topojson.feature(topoData, topoData.objects[topoObjectName]);

        console.log("GeoJSON Data:", geoData);
        if (geoData.features.length === 0) {
            throw new Error("Aucun feature trouvé dans le GeoJSON.");
        }

        // Vérifier les propriétés
        console.log("Propriétés du premier feature:", geoData.features[0].properties);

        // Palette de couleurs en fonction de 'difficulty'
        const difficultyColors = {
          "inconnu": "gray",
          "très facile": "#00FF00",
          "facile": "#FFFF00",
          "modéré": "#FFA500",
          "difficile": "#FF0000",
          "très difficile": "#8B0000"
        };

        // Indexer par difficulté
        const featuresByDifficulty = {};
        geoData.features.forEach(feature => {
            const difficulty = feature.properties.difficulty;
            if (!featuresByDifficulty[difficulty]) {
                featuresByDifficulty[difficulty] = [];
            }
            featuresByDifficulty[difficulty].push(feature);
        });

        // Couche GeoJSON vide initialement
        const geojsonLayer = L.geoJSON(null, {
            style: function(feature){
                const diff = feature.properties.difficulty;
                return { 
                    color: difficultyColors[diff] || "black",
                    weight: 3,
                    opacity: 1 
                };
            },
            onEachFeature: function(feature, layer){
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: zoomToFeature
                });
                layer.bindPopup(
                  `<b>${feature.properties.nom || feature.properties.difficulty_clean || 'N/A'}</b><br />
                   Difficulté: ${feature.properties.difficulty}<br />
                   Pente Moyenne: ${feature.properties.slope_mean !== null ? feature.properties.slope_mean.toFixed(2) : 'N/A'}°<br />
                   Pente Maximum: ${feature.properties.slope_max !== null ? feature.properties.slope_max.toFixed(2) : 'N/A'}°`
                );
            }
        }).addTo(map);

        // Définir la fonction debounce
        function debounce(func, delay) {
            let inDebounce;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(inDebounce);
                inDebounce = setTimeout(() => func.apply(context, args), delay);
            }
        }
        const debouncedUpdate = debounce(updateGeoJSONLayer, 300);

        // Fonctions d'interactivité
        function highlightFeature(e) {
            const layer = e.target;
            layer.setStyle({
                weight: 5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.7
            });
            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                layer.bringToFront();
            }
            info.update(layer.feature.properties);
        }

        function resetHighlight(e) {
            geojsonLayer.resetStyle(e.target);
            info.update();
        }

        function zoomToFeature(e) {
            map.fitBounds(e.target.getBounds());
        }

        // 6) Contrôle de Filtrage
        const filterControl = L.control({position: 'topright'});

        filterControl.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info filter-control');
            div.innerHTML = `
                <h4>Filtrer par Difficulté</h4>
                <label><input type="checkbox" value="inconnu" checked> Inconnu</label><br>
                <label><input type="checkbox" value="très facile" checked> Très Facile</label><br>
                <label><input type="checkbox" value="facile" checked> Facile</label><br>
                <label><input type="checkbox" value="modéré" checked> Modéré</label><br>
                <label><input type="checkbox" value="difficile" checked> Difficile</label><br>
                <label><input type="checkbox" value="très difficile" checked> Très Difficile</label><br>
            `;
            L.DomEvent.disableClickPropagation(div);
            const checkboxes = div.querySelectorAll('input[type=checkbox]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', debouncedUpdate);
            });
            return div;
        };
        filterControl.addTo(map);

        // 7) Fonction de Mise à Jour de la Couche GeoJSON en Fonction des Filtres
        function updateGeoJSONLayer() {
            const checkedDifficulties = Array.from(
              document.querySelectorAll('.filter-control input[type=checkbox]:checked')
            ).map(cb => cb.value);
            
            geojsonLayer.clearLayers();
            
            let filteredFeatures = [];
            checkedDifficulties.forEach(difficulty => {
                if (featuresByDifficulty[difficulty]) {
                    filteredFeatures = filteredFeatures.concat(featuresByDifficulty[difficulty]);
                }
            });
            
            const filteredData = {
                "type": "FeatureCollection",
                "features": filteredFeatures
            };
            
            geojsonLayer.addData(filteredData);
        }

        // 8) Charger le Raster Loamness et l'ajouter
        try {
          const responseRaster = await fetch(rasterUrl);
          if(!responseRaster.ok){
            throw new Error("Fichier Raster Loamness introuvable ou lien invalide.");
          }
          const arrayBuffer = await responseRaster.arrayBuffer();
          
          const georaster = await parseGeoraster(arrayBuffer);
      
          const rasterLayer = new GeoRasterLayer({
            georaster: georaster,
            opacity: 0.6,
            pixelValuesToColorFn: values => {
              if (values[0] === null || isNaN(values[0])) return null;
              const loamness = values[0];
              if (loamness >= 95) return 'rgba(0, 0, 139, 0.6)';        // Bleu Très Foncé
              if (loamness >= 90) return 'rgba(0, 100, 0, 0.6)';        // Vert Foncé
              if (loamness >= 85) return 'rgba(34, 139, 34, 0.6)';       // Vert Moyen
              if (loamness >= 80) return 'rgba(144, 238, 144, 0.6)';     // Vert Clair
              return null; // < 80% => transparent
            },
            resolution: 256 // Ajustez la résolution si nécessaire
          });
      
          rasterLayer.addTo(map);

          // Légende du raster Loamness avec explication correcte
          const rasterLegend = L.control({position: 'bottomleft'});

          rasterLegend.onAdd = function (map) {
              const div = L.DomUtil.create('div', 'info legend'),
                  grades = [80, 85, 90, 95, 100],
                  labels = ["80% – 85%", "85% – 90%", "90% – 95%", "95% – 100%"],
                  colors = [
                      "rgba(144, 238, 144, 0.6)", // Vert Clair
                      "rgba(34, 139, 34, 0.6)",   // Vert Moyen
                      "rgba(0, 100, 0, 0.6)",     // Vert Foncé
                      "rgba(0, 0, 139, 0.6)"      // Bleu Très Foncé
                  ];

              for (let i = 0; i < labels.length; i++) {
                  div.innerHTML +=
                      '<i style="background:' + colors[i] + '"></i> ' +
                      labels[i] + '<br>';
              }

              // Ajouter une séparation et une explication pour le Loamness
              div.innerHTML += '<hr><strong>Loamness (%)</strong><br>';
              div.innerHTML += 'Indice de Loamness : Mesure la proportion de sable, limon et argile dans le sol pour déterminer sa compatibilité avec le VTT. Des sols avec des proportions équilibrées favorisent une meilleure adhérence et maniabilité sur les sentiers.<br><br>';

              // Ajouter une séparation et une explication pour la Pente
              div.innerHTML += '<strong>Pente</strong><br>';
              div.innerHTML += 'Pente Moyenne : Inclinaison moyenne du chemin.<br>';
              div.innerHTML += 'Pente Maximum : Inclinaison maximale rencontrée sur le chemin.';
              return div;
          };

          rasterLegend.addTo(map);

          // Initialiser la couche Chemins + Filtres
          updateGeoJSONLayer();

        } catch(err){
          console.error("Erreur chargement Raster Loamness:", err);
          alert("Erreur chargement Raster Loamness (voir console).");
        }

      } catch(err){
        console.error("Erreur générale:", err);
        alert("Erreur générale lors du chargement de la carte: " + err.message);
      }
    })();
</script>

</body>
</html>
