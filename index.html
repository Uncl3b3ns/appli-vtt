<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Carte Chemins et Loamness</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
      /* Style minimal pour la carte */
      body, html { margin:0; padding:0; }
      #map { width:100%; height:100vh; }
      .info {
          padding: 6px 8px;
          font: 14px/16px Arial, Helvetica, sans-serif;
          background: white;
          background: rgba(255,255,255,0.8);
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
          border-radius: 5px;
      }
      .legend {
          line-height: 18px;
          color: #555;
      }
      .legend i {
          width: 18px;
          height: 18px;
          float: left;
          margin-right: 8px;
          opacity: 0.7;
      }
      .filter-control {
          background: white;
          padding: 10px;
          border-radius: 5px;
          box-shadow: 0 0 15px rgba(0,0,0,0.2);
      }
      .filter-control h4 {
          margin: 0 0 5px 0;
          font-size: 16px;
      }
      .filter-control label {
          font-size: 14px;
      }
    </style>
</head>
<body>

<div id="map"></div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Georaster JS (version 1.6.0) -->
<script src="https://cdn.jsdelivr.net/npm/georaster@1.6.0/dist/georaster.browser.bundle.min.js"></script>
<!-- GeoRasterLayer for Leaflet JS (version 2.3.1) -->
<script src="https://unpkg.com/georaster-layer-for-leaflet/dist/georaster-layer-for-leaflet.min.js"></script>
<!-- TopoJSON JS -->
<script src="https://unpkg.com/topojson@3/dist/topojson.min.js"></script>

<script>
    // Vérification du chargement des bibliothèques
    console.log("Georaster loaded:", typeof parseGeoraster); // Doit afficher 'function'
    console.log("GeoRasterLayer loaded:", typeof GeoRasterLayer); // Doit afficher 'function'
    console.log("TopoJSON loaded:", typeof topojson); // Doit afficher 'object'

    (async function(){
      try {
        // Vérifiez que les bibliothèques sont chargées
        if (typeof parseGeoraster !== 'function') {
          throw new Error("parseGeoraster n'est pas défini. Vérifiez le chargement de la bibliothèque Georaster.");
        }
        if (typeof GeoRasterLayer !== 'function') {
          throw new Error("GeoRasterLayer n'est pas défini. Vérifiez le chargement de la bibliothèque GeoRasterLayer.");
        }
        if (typeof topojson !== 'object') {
          throw new Error("topojson n'est pas défini. Vérifiez le chargement de la bibliothèque TopoJSON.");
        }

        // 1) Charger la config locale
        const responseConfig = await fetch('config/Hérault_config.json');  // Remplacez 'Hérault' par votre département
        if(!responseConfig.ok){
          throw new Error("Erreur lors du chargement du fichier de configuration.");
        }
        const config = await responseConfig.json();
      
        const topojsonUrl = config.topojson_url; // ex: "https://Uncl3b3ns.github.io/appli-vtt/data/Hérault_Chemins_difficulte.topojson"
        const rasterUrl   = config.raster_url;   // ex: "https://Uncl3b3ns.github.io/appli-vtt/raster/Hérault_Loamness.tif"
      
        // 2) Initialiser la carte
        const map = L.map('map').setView([43.6, 3.87], 8); // Centrez selon votre département
      
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom:19,
          attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);
      
        // 3) Ajouter une couche d'informations
        const info = L.control();
      
        info.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'info'); // Création d'un div avec la classe 'info'
            this.update();
            return this._div;
        };
      
        // Méthode pour mettre à jour le contenu de l'info
        info.update = function (props) {
            this._div.innerHTML = '<h4>Difficulté des Chemins</h4>' +  (props ?
                '<b>' + (props.nom || props.difficulty_clean || 'N/A') + '</b><br />' + props.difficulty
                : 'Sélectionnez un chemin');
        };
      
        info.addTo(map);
      
        // 4) Créer une légende pour les chemins
        const legend = L.control({position: 'bottomright'});
      
        legend.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info legend'),
                grades = ["inconnu", "très facile", "facile", "modéré", "difficile", "très difficile"],
                colors = ["gray", "#00FF00", "#FFFF00", "#FFA500", "#FF0000", "#8B0000"]; // Couleurs ajustées
    
            // Générer les étiquettes
            for (let i = 0; i < grades.length; i++) {
                div.innerHTML +=
                    '<i style="background:' + colors[i] + '"></i> ' +
                    grades[i] + '<br>';
            }
      
            return div;
        };
      
        legend.addTo(map);
      
        // 5) Charger le TopoJSON et préparer la couche GeoJSON
        const respTopo = await fetch(topojsonUrl);
        if(!respTopo.ok){
          throw new Error("Fichier TopoJSON introuvable.");
        }
        const topoData = await respTopo.json();
      
        // Convertir TopoJSON en GeoJSON
        if(!topoData.objects){
          throw new Error("Pas d'objet 'objects' dans le TopoJSON.");
        }
        // Remplacez 'features' par le nom correct de l'objet dans votre TopoJSON
        const topoObjectName = Object.keys(topoData.objects)[0]; // Dynamique selon votre TopoJSON
        const geoData = topojson.feature(topoData, topoData.objects[topoObjectName]);
      
        console.log("GeoJSON Data:", geoData); // Pour vérifier les données
        if (geoData.features.length === 0) {
            throw new Error("Aucun feature trouvé dans le GeoJSON.");
        }
      
        // Vérifier les propriétés d'un feature
        console.log("Propriétés du premier feature:", geoData.features[0].properties);
      
        // Définir une palette de couleurs basée sur la difficulté
        const difficultyColors = {
          "inconnu": "gray",
          "très facile": "#00FF00", // Vert vif
          "facile": "#FFFF00",      // Jaune
          "modéré": "#FFA500",      // Orange
          "difficile": "#FF0000",   // Rouge
          "très difficile": "#8B0000" // Rouge foncé
        };
      
        // Pré-indexer les features par difficulté pour optimisation
        const featuresByDifficulty = {};
  
        geoData.features.forEach(feature => {
            const difficulty = feature.properties.difficulty;
            if (!featuresByDifficulty[difficulty]) {
                featuresByDifficulty[difficulty] = [];
            }
            featuresByDifficulty[difficulty].push(feature);
        });
  
        // Créer une couche GeoJSON vide
        const geojsonLayer = L.geoJSON(null, { // Initialement vide
            style: function(feature){
                const difficulty = feature.properties.difficulty;
                return { 
                    color: difficultyColors[difficulty] || "black", 
                    weight: 3, // Épaisseur augmentée pour meilleure visibilité
                    opacity: 1 
                };
            },
            onEachFeature: function(feature, layer){
                layer.on({
                    mouseover: highlightFeature,
                    mouseout: resetHighlight,
                    click: zoomToFeature
                });
                layer.bindPopup(`<b>${feature.properties.nom || feature.properties.difficulty_clean || 'N/A'}</b><br>Difficulté: ${feature.properties.difficulty}`);
            }
        }).addTo(map);
      
        // 6) Définir la Fonction `debouncedUpdate` Avant son Utilisation
        // Fonction debounce pour éviter les appels trop fréquents
        function debounce(func, delay) {
            let inDebounce;
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(inDebounce);
                inDebounce = setTimeout(() => func.apply(context, args), delay);
            }
        }
      
        const debouncedUpdate = debounce(updateGeoJSONLayer, 300);
      
        // 7) Fonctions d'interactivité
        function highlightFeature(e) {
            const layer = e.target;
    
            layer.setStyle({
                weight: 5,
                color: '#666',
                dashArray: '',
                fillOpacity: 0.7
            });
    
            if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
                layer.bringToFront();
            }
    
            info.update(layer.feature.properties);
        }
    
        function resetHighlight(e) {
            geojsonLayer.resetStyle(e.target);
            info.update();
        }
    
        function zoomToFeature(e) {
            map.fitBounds(e.target.getBounds());
        }
      
        // 8) Ajouter les Contrôles de Filtrage
        // Créer un contrôle de filtrage
        const filterControl = L.control({position: 'topright'});
  
        filterControl.onAdd = function (map) {
            const div = L.DomUtil.create('div', 'info filter-control');
            div.innerHTML = `
                <h4>Filtrer par Difficulté</h4>
                <label><input type="checkbox" value="inconnu" checked> Inconnu</label><br>
                <label><input type="checkbox" value="très facile" checked> Très Facile</label><br>
                <label><input type="checkbox" value="facile" checked> Facile</label><br>
                <label><input type="checkbox" value="modéré" checked> Modéré</label><br>
                <label><input type="checkbox" value="difficile" checked> Difficile</label><br>
                <label><input type="checkbox" value="très difficile" checked> Très Difficile</label><br>
            `;
            
            // Empêcher l'interaction avec la carte lorsque l'utilisateur interagit avec les filtres
            L.DomEvent.disableClickPropagation(div);
            
            // Ajouter des écouteurs d'événements aux cases à cocher
            const checkboxes = div.querySelectorAll('input[type=checkbox]');
            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', debouncedUpdate);
            });
            
            return div;
        };
  
        filterControl.addTo(map);
  
        // 9) Fonction de Mise à Jour de la Couche GeoJSON en Fonction des Filtres
        function updateGeoJSONLayer() {
            const checkedDifficulties = Array.from(document.querySelectorAll('.filter-control input[type=checkbox]:checked'))
                .map(cb => cb.value);
            
            geojsonLayer.clearLayers();
            
            let filteredFeatures = [];
            checkedDifficulties.forEach(difficulty => {
                if (featuresByDifficulty[difficulty]) {
                    filteredFeatures = filteredFeatures.concat(featuresByDifficulty[difficulty]);
                }
            });
            
            const filteredData = {
                "type": "FeatureCollection",
                "features": filteredFeatures
            };
            
            geojsonLayer.addData(filteredData);
        }
  
        // 10) Charger le Raster Loamness et l'ajouter à la carte
        try {
          const responseRaster = await fetch(rasterUrl);
          if(!responseRaster.ok){
            throw new Error("Fichier Raster Loamness introuvable.");
          }
          const arrayBuffer = await responseRaster.arrayBuffer();
          
          const georaster = await parseGeoraster(arrayBuffer);
      
          const rasterLayer = new GeoRasterLayer({
            georaster: georaster,
            opacity: 0.6,
            pixelValuesToColorFn: values => {
              if (values[0] === null || isNaN(values[0])) return null;
              const loam = values[0];
              if (loam >= 95) return 'rgba(0, 0, 139, 0.6)';        // Bleu Très Foncé pour 95-100%
              if (loam >= 90) return 'rgba(0, 100, 0, 0.6)';        // Vert Foncé pour 90-95%
              if (loam >= 85) return 'rgba(34, 139, 34, 0.6)';       // Vert Moyen pour 85-90%
              if (loam >= 80) return 'rgba(144, 238, 144, 0.6)';     // Vert Clair pour 80-85%
              return null; // Masquer les zones < 80%
            },
            resolution: 256 // Ajustez la résolution si nécessaire
          });
      
          rasterLayer.addTo(map);
      
          // Ajouter une légende pour le raster (zones ≥ 80%)
          const rasterLegend = L.control({position: 'bottomleft'});
      
          rasterLegend.onAdd = function (map) {
              const div = L.DomUtil.create('div', 'info legend'),
                  grades = [80, 85, 90, 95, 100],
                  labels = ["80% – 85%", "85% – 90%", "90% – 95%", "95% – 100%"],
                  colors = [
                      "rgba(144, 238, 144, 0.6)", // Vert Clair
                      "rgba(34, 139, 34, 0.6)",   // Vert Moyen
                      "rgba(0, 100, 0, 0.6)",     // Vert Foncé
                      "rgba(0, 0, 139, 0.6)"      // Bleu Très Foncé
                  ];
      
              // Générer les étiquettes
              for (let i = 0; i < labels.length; i++) {
                  div.innerHTML +=
                      '<i style="background:' + colors[i] + '"></i> ' +
                      labels[i] + '<br>';
              }
      
              return div;
          };
      
          rasterLegend.addTo(map);
      
          // Initialiser la couche GeoJSON avec tous les filtres cochés
          updateGeoJSONLayer();
      
        } catch(err){
          console.error("Erreur chargement Raster Loamness:", err);
          alert("Erreur chargement Raster Loamness (voir console).");
        }
      
      } catch(err){
        console.error("Erreur générale:", err);
        alert("Erreur générale lors du chargement de la carte: " + err.message);
      }
    })();
</script>

</body>
</html>
